1) Implementation of Queue:

import java.util.* ;
import java.io.*; 

class Node{
        int data;
        Node next;

        Node(int data){
            this.data = data;
            this.next = null;
        }

        Node(int data, Node next){
            this.data= data;
            this.next = next;
        }


}

public class Queue {
    private Node front;
    private Node rear;
    Queue() {
        // Implement the Constructor
        front = null;
        rear = null;
    }

    /*----------------- Public Functions of Queue -----------------*/

    boolean isEmpty() {
        // Implement the isEmpty() function
        return front == null;
    }

    void enqueue(int data) {
        // Implement the enqueue() function
        Node newNode = new Node(data);

        if(rear == null){
            front = newNode;
            rear = newNode;
        }
        else{
            rear.next = newNode;
            rear = newNode;
        }
    }

    int dequeue() {
        // Implement the dequeue() function
        if(isEmpty()){
            return -1;
        }

        int value = front.data;
        front = front.next;
        if(front == null){
            rear = null;
        }
        
        return value;
    }

    int front() {
        // Implement the front() function
        if(isEmpty()){
            return -1;
        }

        return front.data;
    }

}


=============================================================================================================================================================================================================================================================================
2) IMplementation of queue using stack


class MyQueue {
    private Stack<Integer> stack1;
    private Stack<Integer> stack2;
    public MyQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }
    
    public void push(int x) {
        stack1.push(x);
    }
    
    public int pop() {
        if(stack2.isEmpty()){
            while (!stack1.isEmpty()){
                int value = stack1.pop();
                stack2.push(value); 
            }
        }

        return stack2.pop();
    }
    
    public int peek() {
        if(stack2.isEmpty()){
            while (!stack1.isEmpty()){
                int value = stack1.pop();
                stack2.push(value); 
            }
        }

        return stack2.peek();
    }
    
    public boolean empty() {
        return stack1.isEmpty() && stack2.isEmpty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */

===================================================================================================================================================================================================================================================================================

4) GAS STATIONS:

class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int total =  0;
        int curr = 0;
        int station = 0;
        int netGain = 0;

        for(int i = 0; i < gas.length; i++){
            netGain = gas[i] - cost[i];

            total = total + netGain;
            curr = curr + netGain;

            if(curr < 0){
                station = i+1; // if the curr status is negative move to next station
                curr = 0; // start updating the curr again
            }
        }

        if(total >= 0){ // the total should be greater or equal to zero
            return station;
        }
        else{
            return -1;
        }
    }
}

===========================================================================================================================================================================================================================================================

5) LRU cache :

class LRUCache {
    class Node{
        int key;
        int value;

        Node prev = null;
        Node next = null;

        Node(int k, int v){
            this.key = k;
            this.value = v;
        }
    }

    int capacity;
    Node head;
    Node tail;

    HashMap<Integer, Node> map;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        head = null;
        tail = null;
    }
    
    public int get(int key) {
        if(!map.containsKey(key)) return -1; // no such key exist

        Node newNode = map.get(key);
        moveToHead(newNode); // beacuse just now accessed
        return newNode.value;
    }
    
    public void put(int key, int value) {
        // key is in cache
        if(map.containsKey(key)){
            Node newNode = map.get(key);
            newNode.value = value;
            // just now accessed so move to head;
            moveToHead(newNode);
        }
        else{
            //capacity is reached
            if(map.size() >= capacity){
                removeTail();
            }

            Node newNode = new Node(key , value);
            map.put(key, newNode);
            moveToHead(newNode);
        }
    }

    private void moveToHead(Node temp){
        if(temp == head) return;
        if(temp == tail) tail = tail.prev;

        // break link
        if(temp.prev != null) temp.prev.next = temp.next;
        if(temp.next != null) temp.next.prev = temp.prev;
        
        temp.prev = null; // reset before adding the temp to head
        temp.next = null;
        addToHead(temp);
    }

    private void addToHead(Node temp){
        if(head == null) {
            head = temp;
            tail = temp;
            return;
        }
        
        temp.next = head;
        head.prev = temp;
        head = temp;
        temp.prev = null; //reset the prev for temp
    }

    private void removeTail(){
    
        map.remove(tail.key);
        if (head == tail){ // âœ… Only one node
            head = null;
            tail = null;
        } 
        else {
            tail = tail.prev;
            tail.next = null;
        }   
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */


==============================================================================================================================================================================================================================

6) Sliding window maximum

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> d = new ArrayDeque<>();
        int i = 0;
        int j = 0;
        int n = nums.length;
        int[] maximum_window = new int[n - k + 1];
  
        // find the first maximuym element and add it in the array for [0 ... k - 1]
        while(i < k){   
            while(!d.isEmpty() && nums[i] >= nums[d.getLast()]){
                d.removeLast();
            }
            d.addLast(i);
            i = i + 1;
        }
        maximum_window[j] = nums[d.getFirst()];
        j = j + 1;

        // add rest of he maximum elements from [i to n]

        while( i < n ){
            if(!d.isEmpty() && d.getFirst() <= i - k) d.removeFirst();   // remove elements in deque at first if it is out of window

            while(!d.isEmpty() && nums[i] >= nums[d.getLast()]) d.removeLast();

            d.addLast(i);
            i = i + 1;
            maximum_window[j] = nums[d.getFirst()];
            j = j  + 1;
        }

        return maximum_window;
    }
}
