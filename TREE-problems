1)  Binary Tree Level Order Traversal:

class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> arr = new ArrayList<>();

        if(root == null ) return arr;
        
        Queue<TreeNode> q = new ArrayDeque<>();
        
        q.add(root);
        
        while(!q.isEmpty()){
            int size = q.size();
            List<Integer> part = new ArrayList<>();

            for(int i = 0; i < size ; i++){
                TreeNode curr = q.poll();
                part.add(curr.val);
                if(curr.left != null) q.add(curr.left);
                if(curr.right != null) q.add(curr.right);
            }
            arr.add(part);
        }
        
        return arr;
    }
}

==============================================================================================================================================================================================================================

2) preorder traversal

class Solution {
    
    public void traversal(Node curr, ArrayList<Integer> res){
        
        if (curr == null) return;
        
        res.add(curr.data);
        traversal(curr.left, res);
        traversal(curr.right, res);
    }
    
    public ArrayList<Integer> preOrder(Node root) {
        //  code here
       ArrayList<Integer> res = new ArrayList<>();
       traversal(root, res);
       return res;
    }
}

Inorder traversal:

class Solution {
    
    public void traversal(Node curr, ArrayList<Integer> res){
        
        if (curr == null) return;
        
        
        traversal(curr.left, res);
        res.add(curr.data);
        traversal(curr.right, res);
    }
    
    public ArrayList<Integer> inOrder(Node root) {
        // code here
        ArrayList<Integer> res = new ArrayList<>();
       traversal(root, res);
       return res;
    }
}


postOrder traversal:

class Solution {
    
    public void traversal(Node curr, ArrayList<Integer> res){
        
        if (curr == null) return;
        
        
        traversal(curr.left, res);
        traversal(curr.right, res);
        res.add(curr.data);
    }
    
    public ArrayList<Integer> postOrder(Node root) {
        // code here
        ArrayList<Integer> res = new ArrayList<>();
        traversal(root, res);
        return res;
    }
}

==============================================================================================================================================================================================================================

3) Deletion of node in Binary Tree:

/*
Node class is as follows:

class Node {
    int data;
    Node left, right;

    public Node(int data){
        this.data = data;
    }
}
*/
class Solution {
    
    public void deleteLast(Node root, Node delNode){
        Queue<Node> q = new ArrayDeque<>();
        
        q.add(root);
        
        while(!q.isEmpty()){
            Node temp = q.poll();
            
            if(temp == delNode){
                temp = null;
                return;
            }
            
            if(temp.left != null){
                if(temp.left == delNode){
                    temp.left = null;
                    return;
                }
                else{
                    q.add(temp.left);
                }
            }
            
            if(temp.right != null){
                if(temp.right == delNode){
                    temp.right = null;
                    return;
                }
                else{
                    q.add(temp.right);
                }
            }
        }
        
    }
    
    public Node deleteNode(Node root, int key) {
        // code here
        
        if(root == null) return null;
        
        if(root.left == null && root.right == null) return root;
        
        Queue<Node> q = new ArrayDeque<>();
        q.add(root);
        
        Node keyNode = null;
        Node temp = null;
        
        while(!q.isEmpty()){
            temp = q.poll();
            
            if(temp.data == key){
                keyNode = temp;
            }
            
            if(temp.left != null) q.add(temp.left);
            if(temp.right != null) q.add(temp.right);
        }
        
        if(keyNode != null){
            int x = temp.data;
            keyNode.data = x;
            deleteLast(root, temp);
        }
        
        return root;
    }
}

3) Insertion logic:


class Solution {    
    public Node InsertNode(Node root, int key) {
        // code here
        Node newNode = new Node(key);
        if(root == null) return null;
        
        if(root.left == null && root.right == null) return root;
        
        Queue<Node> q = new ArrayDeque<>();
        q.add(root);
            
        while(!q.isEmpty()){
            temp = q.poll();
            if(temp.left == null){
                temp.left = newNode;
                break;
            }
            else{
                q.add(curr.left);
            }

            if(temp.right == null){
                temp.right = newNode;
                break;
            }
            else{
                q.add(curr.right);
            }
        }
        return root;
    }
}

===========================================================================================================================================================================================================================

4) insertion in BST:

class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        TreeNode curr = root;

        if(curr == null) return new TreeNode(val);

        if(val < curr.val) curr.left = insertIntoBST(curr.left, val);
        else curr.right = insertIntoBST(curr.right, val);

        return curr;
    }
}

===========================================================================================================================================================================================================================

5) Search in a BST:

class Solution {
    public boolean search(Node root, int key) {
        // code here
        if(root == null) return false;
        
        Node curr = root;
        
        while(curr != null){
            if(curr.data == key) return true;
            
            else if (key < curr.data) curr = curr.left;
            
            else curr = curr.right;
        }
        
        return false;
    }
}


===========================================================================================================================================================================================================================

6) Same tree:

class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
         if (p == null && q == null) {
            return true;
        }

        // Case 2: One of them is empty, the other isn't
        if ((p == null && q != null) || (p != null && q == null)) {
            return false;
        }

        // Case 3: Values don't match
        if (p.val != q.val) {
            return false;
        }

        // Case 4: Recursively check left and right subtrees
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}

===========================================================================================================================================================================================================================

7) Max depth of a tree:

class Solution {
    public int maxDepth(TreeNode root) {

        if(root == null) return 0;

        Queue<TreeNode> q = new ArrayDeque<>();

        TreeNode curr = root;

        int count = 0;

        q.add(curr);

        while(!q.isEmpty()){
            int size = q.size();

            for(int i = 0 ; i < size ; i++){
                TreeNode temp = q.poll();
                if(temp.left != null) q.add(temp.left);
                if(temp.right != null) q.add(temp.right);
            }
            count++;
        }

        return count;
    }
}

===========================================================================================================================================================================================================================

8) Zig Zag or Spiral Tree:

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        Queue<TreeNode> q = new ArrayDeque<>();

        List<List<Integer>> res = new ArrayList<>();

        if(root == null) return res;

        q.add(root);

        boolean leftToRight = true;

        while(!q.isEmpty()){
            int size = q.size();
            ArrayList<Integer> pair = new ArrayList<>();
            for(int i = 0; i < size; i++){
                
                TreeNode curr = q.poll();
                pair.add(curr.val);

                if(curr.left!=null) q.add(curr.left);
                if(curr.right!=null) q.add(curr.right);
            }

            if(leftToRight == false){
                Collections.reverse(pair);
            }

            res.add(pair);

            leftToRight = !leftToRight;
        }


        return res;
    }
}

===========================================================================================================================================================================================================================

9) Balanced Binary Tree:


class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root == null) return true;

        Queue<TreeNode> q = new ArrayDeque<>();

        q.add(root);

        boolean flag = true;

        while(!q.isEmpty()){
            TreeNode curr = q.poll();

            int leftheight = height(curr.left);
            int rightheight = height(curr.right);

            if(Math.abs(leftheight - rightheight) > 1){
                flag = false;
            }

            if(curr.left != null) q.add(curr.left);
            if(curr.right != null) q.add(curr.right);
        }
        return flag;
    }

    public int height(TreeNode root){
        if(root == null) return 0;

        Queue<TreeNode> q = new ArrayDeque<>();

        q.add(root);

        int heights = 0;

        while(!q.isEmpty()){
            int size = q.size();
            for(int i = 0 ; i < size ; i++){
                TreeNode curr = q.poll();
                if(curr.left != null) q.add(curr.left);
                if(curr.right != null) q.add(curr.right);
            }
            heights++;
        }

        return heights;
    }
}

===========================================================================================================================================================================================================================

10) diameter of the BT:

class Solution {
    public int diameterOfBinaryTree(TreeNode root) {
        if(root == null) return 0;

        Queue<TreeNode> q = new ArrayDeque<>();

        int diameter = 0;

        q.add(root);

        while(!q.isEmpty()){

            TreeNode curr = q.poll();

            int left = getDepth(curr.left);
            int right = getDepth(curr.right);

            diameter =  Math.max(diameter, left + right);

            if(curr.left != null) q.add(curr.left);
            if(curr.right != null) q.add(curr.right);
        }

        return diameter;
    }

    public int getDepth(TreeNode root){
        if(root == null) return 0;
        Queue<TreeNode> q = new ArrayDeque<>();

        q.add(root);

        int count = 0;

        while(!q.isEmpty()){
            int size = q.size();

            for(int i = 0 ; i < size ; i++){
                TreeNode temp = q.poll();

                if(temp.left != null) q.add(temp.left);
                if(temp.right != null) q.add(temp.right);
            }

            count++;
        }
        return  count;
    }
}

==========================================================================================================================================================================================================================

11) level of a node in BT:

class Solution {
    /* Returns level of given data value */
    int getLevel(Node node, int data) {
        // Write your code here
        if(node == null) return 0;
        
        Queue<Node> q = new ArrayDeque<>();
        
        q.add(node);
        
        int level = 1;
        
        while(!q.isEmpty()){
            
            
            int size = q.size();
            
            for(int i  = 0; i < size; i++){
                Node curr = q.poll();
                if(curr.data == data){
                    return level;
                } 
            
                if(curr.left != null) q.add(curr.left);
                if(curr.right != null) q.add(curr.right);
            }
            
            
            level++;
        }
        
        return 0;
    }
}

==========================================================================================================================================================================================================================

12) Invert a BT:

class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return null;

        TreeNode temp = root.right;
        root.right = root.left;
        root.left =  temp;

        invertTree(root.left);
        invertTree(root.right);

        return root;
    }
}

==========================================================================================================================================================================================================================

13) k distance from root:

class Tree {
    // Recursive function to print right view of a binary tree.
    ArrayList<Integer> Kdistance(Node root, int k) {
        // Your code here
        ArrayList<Integer> res = new ArrayList<>();
        
        if(root == null) return res;
        
        Queue<Node> q = new ArrayDeque<>();
        
        q.add(root);
        
        int level = 0;
        
        while(!q.isEmpty()){
            int size = q.size();
            
            
            for(int i = 0 ; i < size; i++){
                Node curr = q.poll();
                
                if(level == k){
                    res.add(curr.data);
                }
                
                if(curr.left != null) q.add(curr.left);
                if(curr.right != null) q.add(curr.right);
            }
            
            level++;
        }
        
        return res;
        
    }
}

==========================================================================================================================================================================================================================

14) root to leaf paths:

class Solution {
    public static ArrayList<ArrayList<Integer>> Paths(Node root) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        if (root == null) return res;
        
        // Helper function to perform DFS
        dfs(root, new ArrayList<>(), res);
        
        return res;
    }
    
    private static void dfs(Node node, ArrayList<Integer> path, ArrayList<ArrayList<Integer>> res) {
        // Add the current node to the path
        path.add(node.data);
        
        // If it's a leaf node, add the path to the result list
        if (node.left == null && node.right == null) {
            res.add(new ArrayList<>(path));
        } else {
            // Recur for left and right children
            if (node.left != null) {
                dfs(node.left, path, res);
                path.remove(path.size() - 1);  // Backtrack
            }
            if (node.right != null) {
                dfs(node.right, path, res);
                path.remove(path.size() - 1);  // Backtrack
            }
        }
    }
}

==========================================================================================================================================================================================================================

15) cousins of BT:

class Solution {
    public boolean isCousins(TreeNode root, int x, int y) {
        if(root == null) return false;

        Queue<TreeNode> q = new ArrayDeque<>();

        q.add(root);

        while(!q.isEmpty()){
            int size = q.size();
            boolean xfound = false;
            boolean yfound = false;

            for(int i = 0; i < size; i++){
                TreeNode curr = q.poll();

                if(curr.left != null && curr.right != null){
                    if((curr.left.val == x && curr.right.val == y) || (curr.left.val  == y && curr.right.val == x)){
                        return false;
                    }
                }

                if(curr.val == x) xfound = true;
                if(curr.val == y) yfound = true;

                if(curr.left != null) q.add(curr.left);
                if(curr.right != null) q.add(curr.right);
            }
            if (xfound && yfound) return true;
            if (xfound || yfound) return false; 
        }
        return false;
    }
}

==========================================================================================================================================================================================================================

16) lowest common ancester:

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return null;

        HashMap<TreeNode, TreeNode> map = new HashMap<>();

        Queue<TreeNode> queue = new LinkedList<>();

        map.put(root, null);
        queue.add(root);

        while(!map.containsKey(p) || !map.containsKey(q)){
            TreeNode curr = queue.poll();

            if(curr.left != null){
                map.put(curr.left, curr);
                queue.add(curr.left);
            }

            if(curr.right != null){
                map.put(curr.right, curr);
                queue.add(curr.right);
            }
        }

        HashSet<TreeNode> s = new HashSet<>();

        while(p != null){
            s.add(p);
            p = map.get(p);
        }

        while(!s.contains(q)){
            q = map.get(q);
        }

        return q;
    }
}

==========================================================================================================================================================================================================================

17) flattening the BT:

class Solution {
    public void flatten(TreeNode root) {
        ArrayList<TreeNode> list = new ArrayList<>(); 
        if(root == null) return;

        preOrder(root, list);

        for(int i = 0; i < list.size() - 1 ; i++){
            TreeNode curr = list.get(i);
            TreeNode next = list.get(i + 1);
            curr.left = null;
            curr.right = next;
        }

    }

    public static void preOrder(TreeNode root, ArrayList<TreeNode> list){
        if(root == null) return;

        list.add(root);
        preOrder(root.left, list);
        preOrder(root.right, list);
    }
}

==========================================================================================================================================================================================================================

18) construct BT with inorder and postorder traversal output:

class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        if(inorder.length == 0 || postorder.length == 0){
            return null;
        }

        int rootval = postorder[postorder.length - 1];
        TreeNode root = new TreeNode(rootval);

        int mid =0;

        for(int i = 0; i < inorder.length; i++){
            if(inorder[i] == rootval){
                mid = i;
            }
        }
        // separate the inorder array with mid
        int[] leftinorder = Arrays.copyOfRange(inorder, 0, mid);
        int[] rightinorder = Arrays.copyOfRange(inorder, mid + 1, inorder.length);

        // separate postorder with leftinorder length

        int[] leftpostorder = Arrays.copyOfRange(postorder, 0, leftinorder.length);
        int[] rightpostorder = Arrays.copyOfRange(postorder, leftinorder.length, postorder.length - 1);

        root.left = buildTree(leftinorder, leftpostorder);
        root.right = buildTree(rightinorder, rightpostorder);

        return root;
    }
}

==========================================================================================================================================================================================================================

19) Binary Tree Maximum Path Sum:

class Solution {
    public int maxPathSum(TreeNode root) {
        if(root == null) return 0;

        int maxsum = Integer.MIN_VALUE;

        HashMap<TreeNode,  Integer> gain = new HashMap<>();
        Stack<Object[]> stack = new Stack<>();

        stack.push(new Object[] {root, false});

        while(!stack.isEmpty()){
            Object[] top = stack.pop();
            TreeNode node = (TreeNode) top[0];
            boolean check = (boolean) top[1];
            

            if(node == null) continue;

            if(check){
                int left = Math.max(0, gain.getOrDefault(node.left,0));
                int right = Math.max(0, gain.getOrDefault(node.right,0));

                int pathsum = node.val + left + right;
                maxsum = Math.max(maxsum, pathsum);

                gain.put(node, node.val + Math.max(left, right));

            }
            else{
                stack.add(new Object[] {node, true});
                stack.add(new Object[] {node.right, false});
                stack.add(new Object[] {node.left, false});
            }
        }
        return maxsum;
    }
}


==========================================================================================================================================================================================================================


20) vertical order traversal:

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    class Pair{
        TreeNode node;
        int col;

        Pair(TreeNode node, int col){
            this.node = node;
            this.col = col;
        }
    }
    public List<List<Integer>> verticalTraversal(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();

        if (root == null) return res;

        TreeMap<Integer, List<Integer>> map = new TreeMap<>();
        Queue<Pair> q = new ArrayDeque<>();
        q.add(new Pair(root, 0));

        while (!q.isEmpty()) {
            int size = q.size();
            // temporary level map to hold values in this BFS level
            Map<Integer, List<Integer>> levelMap = new HashMap<>();

            for (int i = 0; i < size; i++) {
                Pair top = q.poll();
                TreeNode curr = top.node;
                int col = top.col;

                levelMap.putIfAbsent(col, new ArrayList<>());
                levelMap.get(col).add(curr.val);

                if (curr.left != null) q.add(new Pair(curr.left, col - 1));
                if (curr.right != null) q.add(new Pair(curr.right, col + 1));
            }

            // Now sort each column's values for this level and merge into main map
            for (int col : levelMap.keySet()) {
                List<Integer> temp = levelMap.get(col);
                Collections.sort(temp); // ensures same-row nodes are sorted by value
                map.putIfAbsent(col, new ArrayList<>());
                map.get(col).addAll(temp);
            }
        }

        for (List<Integer> p : map.values()) {
            res.add(p);
        }

        return res;   
    }
}


==========================================================================================================================================================================================================================

21) top view:


/*
class Node {
    int data;
    Node left, right;

    Node(int val) {
        this.data = val;
        this.left = null;
        this.right = null;
    }
}
*/
class Solution {
    
    class Pair{
        Node node;
        int height;
        Pair(Node node, int height){
            this.node = node;
            this.height = height;
        }
    }
    public ArrayList<Integer> topView(Node root) {
        // code here
        ArrayList<Integer> topview = new ArrayList<>();
        
        if(root == null) return new ArrayList<>();
        //this map will store the height of first element in every column
        Map<Integer, Integer> map = new TreeMap<>();
        
        Queue<Pair> q = new ArrayDeque<>();
        q.add(new Pair(root, 0));
        
        while(!q.isEmpty()){
            Pair top = q.poll();
            Node curr = top.node;
            int hd = top.height;
            
            
            if(!map.containsKey(hd)){
                map.put(hd, curr.data);
            }
            
            if(curr.left != null){
                q.add(new Pair(curr.left, hd - 1));
            }
            
            if(curr.right != null){
                q.add(new Pair(curr.right, hd + 1));
            }
            
        }
        
        topview.addAll(map.values());
        
        return topview;
    }
}


==========================================================================================================================================================================================================================


22) Bottom view:

/*
class Node {
    int data;
    Node left;
    Node right;

    Node(int data) {
        this.data = data;
        left = null;
        right = null;
    }
}
*/

class Solution {
    class Pair {
        Node node;
        int hd; // horizontal distance
        
        Pair(Node node, int hd) {
            this.node = node;
            this.hd = hd;
        }
    }
    public ArrayList<Integer> bottomView(Node root) {
        // code here
        ArrayList<Integer> bottomViewList = new ArrayList<>();
        
        if (root == null) return bottomViewList;
        
        // TreeMap maintains sorted order of horizontal distances
        Map<Integer, Integer> map = new TreeMap<>();
        
        Queue<Pair> queue = new ArrayDeque<>();
        queue.add(new Pair(root, 0));
        
        while (!queue.isEmpty()) {
            Pair current = queue.poll();
            Node currentNode = current.node;
            int hd = current.hd;
            
            // For bottom view, we always update (store the last seen node at that HD)
            map.put(hd, currentNode.data);
            
            if (currentNode.left != null) {
                queue.add(new Pair(currentNode.left, hd - 1));
            }
            
            if (currentNode.right != null) {
                queue.add(new Pair(currentNode.right, hd + 1));
            }
        }
        
        bottomViewList.addAll(map.values());
        return bottomViewList;
    }
}


==========================================================================================================================================================================================================================


23) left view:

/*
class Node {
    int data;
    Node left, right;

    Node(int val) {
        this.data = val;
        this.left = null;
        this.right = null;
    }
}
*/

class Solution {
    public ArrayList<Integer> leftView(Node root) {
        // code here
        ArrayList<Integer> res = new ArrayList<>();
        
        if(root == null) return res;
        
        Queue<Node> q = new ArrayDeque<>();
        
        q.add(root);
        
        while(!q.isEmpty()){
            int size = q.size();
            
            for(int i = 0; i < size; i++){
                Node curr = q.poll();
                
                if(i == 0){
                    res.add(curr);
                }
                
                if(curr.left != null) q.add(curr.left);
                if(curr.right != null) q.add(curr.right);
            }
        }
        
        return res;
    }
}


==========================================================================================================================================================================================================================


24) right view:


/*
class Node {
    int data;
    Node left, right;

    Node(int val) {
        this.data = val;
        this.left = null;
        this.right = null;
    }
}
*/

class Solution {
    public ArrayList<Integer> leftView(Node root) {
        // code here
        ArrayList<Integer> res = new ArrayList<>();
        
        if(root == null) return res;
        
        Queue<Node> q = new ArrayDeque<>();
        
        q.add(root);
        
        while(!q.isEmpty()){
            int size = q.size();
            
            for(int i = 0; i < size; i++){
                Node curr = q.poll();
                
                if(i == size - 1){
                    res.add(curr);
                }
                
                if(curr.left != null) q.add(curr.left);
                if(curr.right != null) q.add(curr.right);
            }
        }
        
        return res;
    }
}
