1) reverse words in a string:

class Solution {
    public String reverseWords(String s) {
        String[] arr = s.trim().split("\\s+");

        Stack<String> stack = new Stack<>();

        for(int i  = 0 ; i < arr.length; i++){
            stack.add(arr[i]);
        } 

        StringBuilder res = new StringBuilder();
        while(!stack.isEmpty()){
            String val = stack.pop();
            res.append(val);
            if(!stack.isEmpty()){
                res.append(" ");
            }
        }

        return res.toString();
    }
}


============================================================================================================================================================================================================================================================================

2) anagram:

class Solution {
    public static boolean areAnagrams(String s1, String s2) {
        // code here
        if(s1.length() != s2.length()) return false;
        
        HashMap<Character, Integer> map1 = new HashMap<>();
        HashMap<Character, Integer> map2 = new HashMap<>();
        
        char[] arr1 = s1.toCharArray();
        char[] arr2 = s2.toCharArray();
        
        for(Character val : arr1){
            if(map1.containsKey(val)){
                map1.put(val, map1.get(val) + 1);
            }
            else{
                map1.put(val, 1);
            }
        }
        
        for(Character val : arr2){
            if(map2.containsKey(val)){
                map2.put(val, map2.get(val) + 1);
            }
            else{
                map2.put(val, 1);
            }
        }
        
        // for(Character value : map1.keySet()){
        //     if(map2.containsKey(value)){
        //         int num1 = map1.get(value);
        //         int num2 = map2.get(value);
                
        //         if(num1 != num2) return false;
        //     }
        //     else{
        //         return false;
        //     }
        // }
        return map1.equals(map2);
    }
}


============================================================================================================================================================================================================================================================================

3) Isoorphic string:

class Solution {
    public boolean areIsomorphic(String s1, String s2) {
        // code here
        if (s1.length() != s2.length()) return false;

        Map<Character, Character> map1 = new HashMap<>();
        Map<Character, Character> map2 = new HashMap<>();

        for (int i = 0; i < s1.length(); i++) {
            char c1 = s1.charAt(i);
            char c2 = s2.charAt(i);

            // Check mapping from s1 to s2
            if (map1.containsKey(c1)) {
                if (map1.get(c1) != c2) return false;
            } else {
                map1.put(c1, c2);
            }

            // Check mapping from s2 to s1
            if (map2.containsKey(c2)) {
                if (map2.get(c2) != c1) return false;
            } else {
                map2.put(c2, c1);
            }
        }

        return true;
    }
}

============================================================================================================================================================================================================================================================================

4) Minimum number of swaps:

class Solution {
    public int minSwaps(String s) {
        int balance = 0;
        int maxbalance = 0;

        for (char c : s.toCharArray()) {
           if(c == '['){
                balance++;
           }
           else{
                balance--;
           }
           

           maxbalance = Math.min(maxbalance, balance);
        }

        return (-maxbalance + 1 ) / 2 ;
    }
}

                    (OR)

class Solution {
    public int minSwaps(String s) {
        Stack<Character> st = new Stack<>();
        for(char ch : s.toCharArray()){
            if(ch == '['){
                st.push(ch);
            }
            else{
                if(!st.isEmpty()){
                    st.pop();
                }
            }
        }
        return (st.size() + 1) / 2;
    }
}

                    (OR)

class Solution {
    public int minSwaps(String s) {
        Stack<Character> stack = new Stack<>();

        for (char c : s.toCharArray()) {
            if (c == '[') {
                stack.push(c);
            } else {
                if (!stack.isEmpty() && stack.peek() == '[') {
                    stack.pop(); // valid match
                } else {
                    stack.push(c); // unmatched ]
                }
            }
        }

        // stack now contains unmatched brackets
        // Every 2 unmatched brackets (one [ and one ]) require 1 swap
        int unmatched = stack.size(); // should be even
        return unmatched / 2;
    }
}

=================================================================================================================================================================================================================================================

5) Pattern searching : [Sliding window]:

class Solution {
    public static boolean searchPattern(String txt, String pat) {
        // code here
        int n = txt.length();
        int m = pat.length();
        
        for(int i = 0 ; i <= n - m ; i++){
            int j;
            for(j = 0; j < m ; j++){
                if(txt.charAt(i + j) != pat.charAt(j)){
                    break;
                }
            }
            
            if(j == m){
                return true;
            }
        }
        
        return false;
    }
}


