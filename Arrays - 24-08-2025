1) TRIPLE SUM:

Best solution:  [MY SOLUTION IS AT SECOND WHICH HAS BIT LESS PERFORMANCE]

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int sum = 0;
        List<List<Integer>> res =  new ArrayList<>();
        for(int i = 0 ; i < nums.length - 2;  i++){ // take first element and go one by one
                                                    // dont need to go to last because while i  = n - 2, l will be i + 1 
                                                    // andr will be at n -1 
            if(i > 0 && nums[i] == nums[i - 1]){
                continue; // why i > 0 is because we cant find nums[i-1] which is nums[-1] 
                          // this will remove duplicates while selection
            }
            int l = i + 1;
            int r = nums.length - 1;
            while(l < r){
                sum = nums[i] + nums[l] + nums[r];
                if (sum == 0){
                    ArrayList<Integer> pair =  new ArrayList<>();
                    pair.add(nums[i]);
                    pair.add(nums[l]);
                    pair.add(nums[r]);

                    res.add(pair);

                    while(l < r && nums[l] == nums[l + 1]){
                        l++;
                    }

                    while(l < r && nums[r] == nums[r - 1]){
                        r--;
                    }

                    l++;
                    r--;
                }
                else if (sum < 0 ){
                    l++;
                }
                else {
                    r--;
                }
            }           
        }
    return res;
    }
}

                          (OR)

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int sum = 0;
        HashSet<List<Integer>> set = new HashSet<>();
        for(int i = 0 ; i < nums.length; i++){
            int l = i + 1;
            int r = nums.length - 1;
            while(l < r){
                sum = nums[i] + nums[l] + nums[r];
                if (sum == 0){
                    ArrayList<Integer> pair = new ArrayList<>();
                    pair.add(nums[i]);
                    pair.add(nums[l]);
                    pair.add(nums[r]);
                    set.add(pair);
                    l++;
                    r--;
                }
                else if (sum < 0 ){
                    l++;
                }
                else {
                    r--;
                }
            }           
        }
    return new ArrayList<>(set);
    }
}

                            (OR)

Trivial Approach:

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int sum = 0;
        HashSet<List<Integer>> set = new HashSet<>();
        for(int i = 0 ; i < nums.length; i++){
            for(int j = i + 1 ; j < nums.length ; j++){
                for(int k = j + 1 ; k < nums.length; k++){
                    sum = nums[i] + nums[j] + nums[k];

                    if(sum == 0 && i!=j && i!=k && j!=k){
                       ArrayList<Integer> pair = new ArrayList<>();
                       pair.add(nums[i]);  
                       pair.add(nums[j]);
                       pair.add(nums[k]);
                       Collections.sort(pair);
                       set.add(pair);
                       
                    }

                    
                }
            }
        }
    return new ArrayList<>(set);
    }
}


In GEEK FOR GEEKS

class Solution {
    public boolean hasTripletSum(int arr[], int target) {
        // code Here
        Arrays.sort(arr); // important for two-pointer
        HashSet<List<Integer>> set = new HashSet<>();
        
        for (int i = 0; i < arr.length - 2; i++) {
            int l = i + 1;
            int r = arr.length - 1;
            
            while (l < r) {
                int sum = arr[i] + arr[l] + arr[r];
                
                if (sum == target) {
                   
                    return true;
                  
                } 
                else if (sum < target) {
                    l++;
                } 
                else {
                    r--;
                }
            }
        }
        
        return false;
    }
}

=============================================================================================================================================================================================================================================================================

2) Rotate array :

class Solution {
    public static void reverse(int[] nums, int low, int right){
        while(low < right){
            int temp = nums[low];
            nums[low] = nums[right];
            nums[right] = temp;

            low++;
            right--;
        }
    }
    public void rotate(int[] nums, int k) {
        int n = nums.length;

        k = k % n;
        int l = 0 ; 
        int r = n - 1;
        reverse(nums, l, r);

        reverse(nums, l , k - 1);

        reverse(nums, k , r);

    }
}

                        (OR)

class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;

        k = k % n; // This ensures that the number of rotations never exceeds the array length.
                   // this helps if k > n

        int l = 0 ; 
        int r = n - 1;

        if ( n == 1) return;

        while(l < r){
            int temp = nums[l];
            nums[l] = nums[r];
            nums[r] = temp;
            l++;
            r--;
        }

        l = 0;
        r = k-1;

        while(l < r) {
            int temp = nums[l];
            nums[l] = nums[r];
            nums[r] = temp;
            l++;
            r--;
        }

        l = k ;
        r = n - 1;
        while(l < r) {
            int temp = nums[l];
            nums[l] = nums[r];
            nums[r] = temp;
            l++;
            r--;
        }

    }
}
