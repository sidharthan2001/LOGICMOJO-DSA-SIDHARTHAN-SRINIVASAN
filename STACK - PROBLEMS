1) stack using linkedlist:

class MyStack {
    // class StackNode {
    //     int data;
    //     StackNode next;
    //     StackNode(int a) {
    //         data = a;
    //         next = null;
    //     }
    // }
    StackNode top;

    // Function to push an integer into the stack.
    void push(int a) {
        // Add your code here
        StackNode newNode = new StackNode(a);
        newNode.next = top;
        top = newNode;
    }

    // Function to remove an item from top of the stack.
    int pop() {
        // Add your code here
        if(top == null) return -1;
        int value = top.data;
        top = top.next;
        return value;
    }
}

===============================================================================================================================================================================================================================================================================

2) Implement stack using queue:


class MyStack {
    private Queue<Integer> queue;
    public MyStack() {
        queue = new LinkedList<>();
    }
    
    public void push(int x) {
        queue.add(x);

        int size = queue.size();

        for(int i = 0; i < size - 1; i++){
            int val = queue.remove();
            queue.add(val);
        }
    }
    
    public int pop() {
        return queue.remove();
    }
    
    public int top() {
        return queue.peek();
    }
    
    public boolean empty() {
        return queue.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */

==============================================================================================================================================================================================================================================================================

3) valid paranthesis:

class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();

        char arr[] = s.toCharArray();

        for(int i = 0 ; i < arr.length; i++){
            if(arr[i] == '(' || arr[i] == '[' || arr[i] == '{'){
                
                stack.push(arr[i]);
            }
            else{
                if(stack.isEmpty()){
                    return false;
                }
                else{
                    char top = stack.pop();
                    if(arr[i] == ')' && top != '(' ||
                        arr[i] == ']' && top != '[' ||
                        arr[i] == '}' && top != '{') return false;

                }
            }
        }
        return stack.isEmpty();
    }
}


==============================================================================================================================================================================================================================

4) min stack:

import java.util.Stack;

class MinStack {
    private Stack<Integer> stack;
    private Stack<Integer> minstack;

    public MinStack() {
        stack = new Stack<>();
        minstack = new Stack<>();
    }

    public void push(int val) {
        stack.push(val);
        // If minstack is empty or val <= current minimum, push to minstack
        if (minstack.isEmpty() || val <= minstack.peek()) {
            minstack.push(val);
        }
    }

    public void pop() {
        // Pop from both stacks if the top values match
        if (!stack.isEmpty()) {
            int removed = stack.pop();
            if (!minstack.isEmpty() && removed == minstack.peek()) {
                minstack.pop();
            }
        }
    }

    public int top() {
        // LeetCode guarantees this won't be called on an empty stack
        return stack.peek();
    }

    public int getMin() {
        // LeetCode guarantees this won't be called on an empty stack
        return minstack.peek();
    }
}


==============================================================================================================================================================================================================================

5) stock span problems:  


class Solution {
    public ArrayList<Integer> calculateSpan(int[] arr) {
        // code here
        Stack<Integer> stack = new Stack<>();
        ArrayList<Integer> res = new ArrayList<>();
        
        for(int i = 0 ; i < arr.length; i++){
            while(!stack.isEmpty() && arr[stack.peek()] <= arr[i]){
                stack.pop();
            }
            
            res.add(stack.isEmpty() ? i + 1 : i - stack.peek()); //[the idea is to create stack where is has increasing monotonic values]
                                                                 // the stack hjas the index value of elements. pop all the index of elements in stack which are lesser than current value.
                                                                 // add i + 1 if stack is empty or (i - stack.peek()) which is until you find an element which is greater than the current element
            
            stack.push(i);
        }
        return res;
    }
}


6) CELEBRITY PROBLEMS:

class Solution {
    public int celebrity(int mat[][]) {
        // code here
        Stack<Integer> stack = new Stack<>();
        int n = mat.length - 1;
        int celeb = -1;
        
        while(n >= 0){
            stack.push(n);
            n--;
        }
        
        while(stack.size() > 1){
            int first = stack.pop();
            int second = stack.pop();
            
            if(mat[first][second] == 1) stack.push(second);
            else stack.push(first);
        }
        
        celeb = stack.peek();
        
        for(int i = 0; i < mat.length; i++){
            if(celeb != i && mat[celeb][i] == 1) return -1;
            if(celeb != i && mat[i][celeb] == 0) return -1;
        }
        
        return celeb;
    }
}
