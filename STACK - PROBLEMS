1) stack using linkedlist:

class MyStack {
    // class StackNode {
    //     int data;
    //     StackNode next;
    //     StackNode(int a) {
    //         data = a;
    //         next = null;
    //     }
    // }
    StackNode top;

    // Function to push an integer into the stack.
    void push(int a) {
        // Add your code here
        StackNode newNode = new StackNode(a);
        newNode.next = top;
        top = newNode;
    }

    // Function to remove an item from top of the stack.
    int pop() {
        // Add your code here
        if(top == null) return -1;
        int value = top.data;
        top = top.next;
        return value;
    }
}

===============================================================================================================================================================================================================================================================================

2) Implement stack using queue:


class MyStack {
    private Queue<Integer> queue;
    public MyStack() {
        queue = new LinkedList<>();
    }
    
    public void push(int x) {
        queue.add(x);

        int size = queue.size();

        for(int i = 0; i < size - 1; i++){
            int val = queue.remove();
            queue.add(val);
        }
    }
    
    public int pop() {
        return queue.remove();
    }
    
    public int top() {
        return queue.peek();
    }
    
    public boolean empty() {
        return queue.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */

==============================================================================================================================================================================================================================================================================

3) valid paranthesis:

class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();

        char arr[] = s.toCharArray();

        for(int i = 0 ; i < arr.length; i++){
            if(arr[i] == '(' || arr[i] == '[' || arr[i] == '{'){
                
                stack.push(arr[i]);
            }
            else{
                if(stack.isEmpty()){
                    return false;
                }
                else{
                    char top = stack.pop();
                    if(arr[i] == ')' && top != '(' ||
                        arr[i] == ']' && top != '[' ||
                        arr[i] == '}' && top != '{') return false;

                }
            }
        }
        return stack.isEmpty();
    }
}


==============================================================================================================================================================================================================================

4) min stack:

import java.util.Stack;

class MinStack {
    private Stack<Integer> stack;
    private Stack<Integer> minstack;

    public MinStack() {
        stack = new Stack<>();
        minstack = new Stack<>();
    }

    public void push(int val) {
        stack.push(val);
        // If minstack is empty or val <= current minimum, push to minstack
        if (minstack.isEmpty() || val <= minstack.peek()) {
            minstack.push(val);
        }
    }

    public void pop() {
        // Pop from both stacks if the top values match
        if (!stack.isEmpty()) {
            int removed = stack.pop();
            if (!minstack.isEmpty() && removed == minstack.peek()) {
                minstack.pop();
            }
        }
    }

    public int top() {
        // LeetCode guarantees this won't be called on an empty stack
        return stack.peek();
    }

    public int getMin() {
        // LeetCode guarantees this won't be called on an empty stack
        return minstack.peek();
    }
}


==============================================================================================================================================================================================================================

5) stock span problems:  


class Solution {
    public ArrayList<Integer> calculateSpan(int[] arr) {
        // code here
        Stack<Integer> stack = new Stack<>();
        ArrayList<Integer> res = new ArrayList<>();
        
        for(int i = 0 ; i < arr.length; i++){
            while(!stack.isEmpty() && arr[stack.peek()] <= arr[i]){
                stack.pop();
            }
            
            res.add(stack.isEmpty() ? i + 1 : i - stack.peek()); //[the idea is to create stack where is has increasing monotonic values]
                                                                 // the stack hjas the index value of elements. pop all the index of elements in stack which are lesser than current value.
                                                                 // add i + 1 if stack is empty or (i - stack.peek()) which is until you find an element which is greater than the current element
            
            stack.push(i);
        }
        return res;
    }
}

=============================================================================================================================================================================================================================

6) CELEBRITY PROBLEMS:

class Solution {
    public int celebrity(int mat[][]) {
        // code here
        Stack<Integer> stack = new Stack<>();
        int n = mat.length - 1;
        int celeb = -1;
        
        while(n >= 0){
            stack.push(n);
            n--;
        }
        
        while(stack.size() > 1){
            int first = stack.pop();
            int second = stack.pop();
            
            if(mat[first][second] == 1) stack.push(second);
            else stack.push(first);
        }
        
        celeb = stack.peek();
        
        for(int i = 0; i < mat.length; i++){
            if(celeb != i && mat[celeb][i] == 1) return -1;
            if(celeb != i && mat[i][celeb] == 0) return -1;
        }
        
        return celeb;
    }
}
                    (OR)

class Solution {
    public int celebrity(int mat[][]) {
        // code here
        Stack<Integer> stack = new Stack<>();
        int l = 0;
        int r = mat.length - 1;
     
        
        while( l < r ){
            if(mat[l][r] == 1){
                l++;
            }
            else{
                r--;
            }
        }
        
        
        int candidate = l;
        
        for(int i = 0; i < mat.length; i++){
            if(candidate != i){
                if(mat[candidate][i] == 1 || mat[i][candidate] == 0) return -1;
            }
        }
        
        return candidate;



    }
}

=============================================================================================================================================================================================================================

7) Largest rectangle in histogram problem:

NAIVE APPOROACH:

class Solution {             
    public int largestRectangleArea(int[] heights) {
        int res = 0;
        int n = heights.length;

        for(int i = 0; i < n; i++){
            int curr = heights[i];

            //check for height bar in left, take j and go to the left of i and it should stop at 0 and it height[j] >= height[i]
            for(int j = i - 1 ; j >= 0 && heights[j] >= heights[i] ; j--){
                curr = curr + heights[i];
            }

            for(int j = i + 1 ; j < n && heights[j] >= heights[i] ; j++){
                curr = curr + heights[i];
            }

            res = Math.max(curr, res);
        }
        return res;
    }
}

                        (OR)

BEST APPROACH:

class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int maxArea = 0;
        Stack<Integer> stack = new Stack<>();

        // try to add the increasing order of indices in the stack
        for (int i = 0; i <= n; i++) {
            int curr_height;
            if(i == n){
                curr_height = 0;          
            }
            else{
                curr_height = heights[i];
            }

            while(!stack.isEmpty() && curr_height < heights[stack.peek()]){
                int index = stack.pop();
                int height = heights[index];

                int width;
                if(stack.isEmpty()){
                    width = i;
                }
                else{
                    width = i - stack.peek() - 1;
                }

                int area = height * width;

                maxArea = Math.max(area, maxArea);
            }

            stack.push(i);
        }

        return maxArea;
    }
}


                        (OR)


class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int maxArea = 0;

        // Try every bar as the smallest bar in a rectangle
        for (int i = 0; i < n; i++) {
            int height = heights[i];

            // Expand to the left
            int left = i;
            while (left > 0 && heights[left - 1] >= height) {
                left--;
            }

            // Expand to the right
            int right = i;
            while (right < n - 1 && heights[right + 1] >= height) {
                right++;
            }

            // Calculate width and area
            int width = right - left + 1;
            int area = height * width;

            // Update maximum area
            maxArea = Math.max(maxArea, area);
        }

        return maxArea;
    }
}
